# QtJunqi-说明文档

![image-20210822170242809](https://img.i207m.top/2021/08_ce82f1ac0c6a05b260479cb34c75a3b9.png)

## 工作流程

核心设计思想是，首先完成本地双人对战的逻辑，然后**实现网络对战只需相互发送鼠标点击事件**即可。

程序分为三个大部分：MainWindow类仅负责界面显示；Chessboard类负责处理游戏逻辑（如初始化棋盘，处理点击事件，判断游戏结束等）；Piece类负责处理棋子的状态，PieceDisplay是Piece的子类，负责处理棋子的显示。

通过放置60个ClickableLabel（继承自QLabel）对应60个棋子，来实现检测鼠标点击。

点击开始游戏后，首先初始化棋子和其他参数。随后等待用户交互。ClickableLabel将鼠标点击事件传递给后台Chessboard，Chessboard检查棋子的移动或攻击行为是否符合规则，若符合，则调用相应的Piece实例的方法，更新棋子状态和显示。当一回合结束后，Chessboard判断游戏是否结束，并重置计时器。

通过以上流程，可以实现本地双人对战。

### 客户端工作流程

除了以上流程外，客户端需要在创建时，弹出输入IP的窗口，通过正则表达式判断IP是否合法，并尝试连接主机。

### 服务端工作流程

除了以上流程外，服务端需要在创建时，显示本机IP，并新建QTcpserver实例，监听某一端口。

## 网络通信

每个包以控制位开始，控制位的范围是100-106。选择从100开始的原因是，我们保证包的数据部分的最大值<100，由此可以快速判断某一位是否是控制位。以下用`ctrl`表示控制位的值。

- `ctrl==100`

  表示连接成功。数据部分为空。当新socket创建后，由server发至client，指示client连接成功。

- `ctrl==101`

  表示同步棋盘。数据部分为50\*7 bytes，表示50个棋子的状态。

- `ctrl==102`

  表示按下开始。数据部分为1 byte，是一个0-99随机权值，用以判断先手。

  判断先手的方法：比较自己的随机权值和对手的随机权值的大小，权值大者为先手。这样做的好处是，服务端和客户端的逻辑是完全一致的，减少代码量。

- `ctrl==103`

  表示心跳包。数据部分为空。每0.5s发送一个心跳包。

- `ctrl==104`

  表示鼠标点击事件。数据部分为2 bytes，表示点击的行和列。

- `ctrl==105`

  表示对方认输。数据部分为空。

- `ctrl==106`

  表示对方超时。数据部分为空。

由于传输的数字均<128，可以储存在char里，故不需要考虑端序问题。

## GUI界面设计

GUI界面设计整体较为直观明朗，使用简单，且信息量丰富。主体为军棋棋盘。为显示玩家信息、倒计时等，于棋盘右侧扩展一列：

- 最上方是倒计时，使用Qt自带的LCD Number部件显示。

- 其下是用QLabel实现的玩家信息显示，带有红蓝颜色。

- 为了显示游戏信息，添加Text Browser部件。这样做的好处是在不打断玩家、不阻塞事件循环的情况下（与弹窗相比），持续显示更多信息，也方便调试。

- 最下方是按钮。使用弹簧进行部件的分隔。

